class Solution:
    def restoreIpAddresses(self, s: str) -> list[str]:
        res = []
        
        # Optimization: If string is too long or too short for 4 segments
        if len(s) < 4 or len(s) > 12:
            return []

        def backtrack(start, dots, current_ip):
            # Base Case: We found 4 segments
            if dots == 4:
                # If we also used all characters, it's a valid IP
                if start == len(s):
                    res.append(".".join(current_ip))
                return

            # Try taking 1, 2, or 3 characters for the next segment
            for length in range(1, 4):
                # Ensure we don't go out of bounds
                if start + length > len(s):
                    break
                
                segment = s[start : start + length]
                
                # Validation Logic:
                # 1. No leading zeros (unless the segment is just "0")
                if segment.startswith('0') and len(segment) > 1:
                    continue
                # 2. Value must be <= 255
                if int(segment) > 255:
                    continue
                
                # If valid, proceed to the next segment
                current_ip.append(segment)
                backtrack(start + length, dots + 1, current_ip)
                # Backtrack: remove the last segment added
                current_ip.pop()

        backtrack(0, 0, [])
        return res
